declare const LionSelectRich_base: typeof LionListbox & import("@open-wc/dedupe-mixin").Constructor<import("../../overlays/types/OverlayMixinTypes.js").OverlayHost> & Pick<typeof import("../../overlays/types/OverlayMixinTypes.js").OverlayHost, "prototype"> & Pick<typeof import("lit").LitElement, "prototype" | "_$litElement$" | "enabledWarnings" | "enableWarning" | "disableWarning" | "addInitializer" | "_initializers" | "elementProperties" | "properties" | "elementStyles" | "styles" | "observedAttributes" | "createProperty" | "getPropertyOptions" | "shadowRootOptions"> & import("@open-wc/dedupe-mixin").Constructor<import("@open-wc/scoped-elements/types.js").ScopedElementsHost> & import("@open-wc/dedupe-mixin").Constructor<import("../../core/types/SlotMixinTypes.js").SlotHost> & Pick<typeof import("../../core/types/SlotMixinTypes.js").SlotHost, "prototype">;
/**
 * LionSelectRich: wraps the <lion-listbox> element
 */
export class LionSelectRich extends LionSelectRich_base {
    static get scopedElements(): {
        'lion-select-invoker': typeof LionSelectInvoker;
    };
    /** @type {any} */
    static get properties(): any;
    /**
     * @enhance FormControlMixin
     * @protected
     */
    protected _inputGroupInputTemplate(): import("lit-html").TemplateResult<1>;
    /**
     * @protected
     * @type {LionSelectInvoker}
     */
    protected get _invokerNode(): LionSelectInvoker;
    /**
     * @protected
     * @configure FocusMixin
     */
    protected get _focusableNode(): LionSelectInvoker;
    /**
     * When invoker has focus, up and down arrow keys changes active state of listbox,
     * without opening overlay.
     * @type {Boolean}
     */
    navigateWithinInvoker: boolean;
    /**
     * Aligns behavior for 'selectionFollowFocus' and 'navigateWithinInvoker' with
     * platform. When 'auto' (default), platform is automatically detected
     * @type {'windows/linux'|'mac'|'auto'}
     */
    interactionMode: 'windows/linux' | 'mac' | 'auto';
    singleOption: boolean;
    /** @protected */
    protected _arrowWidth: number;
    /**
     * @param {KeyboardEvent} ev
     * @protected
     */
    protected __onKeyUp(ev: KeyboardEvent): void;
    /** @private */
    private __invokerOnBlur;
    /** @private */
    private __overlayOnHide;
    /** @private */
    private __overlayOnShow;
    /** @private */
    private __invokerOnClick;
    /** @private */
    private __overlayBeforeShow;
    /** @protected */
    protected _listboxOnClick(): void;
    connectedCallback(): void;
    /**
     * @param {string} [name]
     * @param {unknown} [oldValue]
     * @param {import('lit').PropertyDeclaration} [options]
     * @returns {void}
     */
    requestUpdate(name?: string | undefined, oldValue?: unknown, options?: import("lit").PropertyDeclaration<any, any> | undefined): void;
    /**
     * @param {import('lit').PropertyValues } changedProperties
     */
    updated(changedProperties: import('lit').PropertyValues): void;
    /**
     * @enhance FprmRegistrarMixin make sure children have specific default states when added
     * @param {LionOption & FormControlHost} child
     * @param {Number} indexToInsertAt
     */
    addFormElement(child: LionOption & FormControlHost, indexToInsertAt: number): void;
    __hasInitialSelectedFormElement: boolean | undefined;
    /**
     * In the select disabled options are still going to a possible value for example
     * when prefilling or programmatically setting it.
     * @override ChoiceGroupMixin
     * @protected
     */
    protected override _getCheckedElements(): import("../../listbox/src/LionOption.js").LionOption[];
    /** @protected */
    protected _onFormElementsChanged(): void;
    /** @private */
    private __initInteractionStates;
    /** @private */
    private __toggleInvokerDisabled;
    /** @private */
    private __syncInvokerElement;
    /** @private */
    private __setupInvokerNode;
    /** @private */
    private __setupInvokerNodeEventListener;
    /** @private */
    private __teardownInvokerNode;
    /**
     * @configure OverlayMixin
     * @protected
     */
    protected _defineOverlayConfig(): {
        visibilityTriggerFunction: undefined;
        placementMode?: "global" | "local" | undefined;
        popperConfig?: Partial<import("@popperjs/core/index.js").Options> | undefined;
        viewportConfig?: import("../../overlays/types/OverlayConfig.js").ViewportConfig | undefined;
        isBlocking?: boolean | undefined;
        inheritsReferenceWidth?: "none" | "max" | "full" | "min" | undefined;
        zIndex?: number | undefined;
        invokerNode?: HTMLElement | undefined;
        referenceNode?: HTMLElement | undefined;
        contentNode?: HTMLElement | undefined;
        contentWrapperNode?: HTMLElement | undefined;
        backdropNode?: HTMLElement | undefined;
        elementToFocusAfterHide?: HTMLElement | undefined;
        hasBackdrop?: boolean | undefined;
        preventsScroll?: boolean | undefined;
        trapsKeyboardFocus?: boolean | undefined;
        hidesOnEsc?: boolean | undefined;
        hidesOnOutsideClick?: boolean | undefined;
        hidesOnOutsideEsc?: boolean | undefined;
        handlesAccessibility?: boolean | undefined;
        isTooltip?: boolean | undefined;
        invokerRelation?: "label" | "description" | undefined;
        _noDialogEl?: Boolean | undefined;
    };
    /**
     * With no selected element, we should override the inheritsReferenceWidth in most cases.
     * By default, we will set it to 'min', and then set it back to what it was initially when
     * something is selected.
     * As a subclasser you can override this behavior.
     * @protected
     */
    protected _noDefaultSelectedInheritsWidth(): void;
    _initialInheritsReferenceWidth: "none" | "max" | "full" | "min" | undefined;
    /**
     * Align invoker width with content width
     * Make sure display is not set to "none" while calculating the content width
     * @protected
     */
    protected _alignInvokerWidth(): Promise<void>;
    /**
     * @configure FormControlMixin
     * @protected
     */
    protected _onLabelClick(): void;
    /**
     * @configure OverlayMixin
     * @protected
     */
    protected get _overlayInvokerNode(): LionSelectInvoker;
    /**
     * @configure OverlayMixin
     * @protected
     */
    protected get _overlayContentNode(): import("../../listbox/src/LionOptions.js").LionOptions;
    /**
     * Normally, when textbox gets focus or a char is typed, it opens listbox.
     * In transition phases (like clicking option) we prevent this.
     * @private
     */
    private __blockListShowDuringTransition;
    __blockListShow: boolean | undefined;
}
export type LionOptions = import('../../listbox/src/LionOptions.js').LionOptions;
export type LionOption = import('../../listbox/src/LionOption.js').LionOption;
export type FormRegisteringHost = import('../../form-core/types/registration/FormRegisteringMixinTypes.js').FormRegisteringHost;
export type FormControlHost = import('../../form-core/types/FormControlMixinTypes.js').FormControlHost;
export type SlotsMap = import('../../core/types/SlotMixinTypes.js').SlotsMap;
import { LionListbox } from "../../../exports/listbox.js";
import { LionSelectInvoker } from "./LionSelectInvoker.js";
export {};
//# sourceMappingURL=LionSelectRich.d.ts.map